# Coqのタクティック

- Coqのタクティックについて、見つけたものに対してのメモ
- `move=> 変数名`
  - スタックのトップからローカルコンテキストに変数を動かす
  - SSReflectのタクティック
- `move: 変数名`
  - ローカルコンテキストからトップに変数を動かす
  - SSReflectのタクティック
- `intros`
  - 変数定義とその仮定部分に名前をつけて、コンテキストに移せる
  - 例えば、`forall x: nat, A x -> B x`に対して使うと、`forall x: nat, A x`をコンテキストに移せる
  - 多分`move=>`とほぼ同じ動き
- `generalize dependent 変数名`
  - コンテキストの変数を、forallの形でトップに持ってくる
  - 多分`move:`とほぼ同じ動き
- `distruct 変数名`
  - 変数の型を分解する。例えば、pが`pair (n1 n2)`のようなら、`distruct p`とするとn1とn2が出てくる
  - `distruct 変数名 as [変数名]`
- `apply`
  - トップにある定理を使って、他の要素を置き換える
  - moveと合わせた動きも書けるらしい
  - `apply /補題名`
    - 補題を使うこともできる
  - SSReflectのタクティック
- `assumption`
  - コンテキストを使ってゴールに変換できる仮説を探す
  - `by []`の一部機能みたいな感じかな？
- `unfold`
  - 指定した名前の定義を展開してくれる
- `rewrite 補題名`
  - 関数・補題を指定して、その式を左辺のものから右辺のものに置き換える
  - `rewrite- 補題名`
    - 右辺から左辺に置き換えるものに変わる
  - `rewrite /=`
    - 定義をたどる程度の計算をしてくれる
  - `rewrite /定義名`
    - 定義名の定義を紐解いて、展開してくれる
  - `rewrite (_ : もとの変数名 = 新しい変数名)`
    - 変数を置き換えて、置き換えに必要なゴールを追加する
    - substでできる場合はsubstを使ったほうが簡単
  - SSReflectのタクティック
- `subst`
  - `n = m`のような置き換えがコンテキストにあったときに、自動で置き換えてくれる
- `case`
  - 場合分けをする
  - SSReflectのタクティック
- `elim`
  - 帰納法を使う
  - SSReflectのタクティック
- `induction`
  - 帰納法を使う
- `clear`
   - 指定したコンテキストを削除する
   - コンテキストを別の形に変換して、残った元のやつを消すときに使う
- `specialize (補題名 変数名)`
  - forallになっているコンテキストに対して、変数を指定する
- `inversion 補題名`
  - Inductiveで定義された関係を見て、それに合致する命題をいくつか生成する
- `exists`
  - existになってるトップに対して使えるっぽい？
- `try タクティック名`
  - 名前から想像するに、失敗してもいい的な・・・？
- `split`
  - 謎
